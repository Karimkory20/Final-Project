# -*- coding: utf-8 -*-
"""LSTM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GC8cgHmQrGiC3vhvjUSbwTMZgnX18bRv
"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error
from sklearn.model_selection import train_test_split
import os
import pandas as pd
import json
from sklearn.preprocessing import MinMaxScaler


def load_data(file_path):
    try:
        if file_path.endswith('.xlsx'):
            df = pd.read_excel(file_path)
        else:
            df = pd.read_csv(file_path)

        df['AttackDate'] = pd.to_datetime(df['AttackDate'])
        df = df.sort_values(['AttackDate', 'Country'])
        df['Total_Attack_Percentage'] = df['Total_Attack_Percentage'].apply(
            lambda x: x.split('%')[0] if isinstance(x, str) else x
        )
        df['Total_Attack_Percentage'] = pd.to_numeric(df['Total_Attack_Percentage'], errors='coerce') / 100
        df = df.dropna(subset=['Total_Attack_Percentage', 'Country', 'AttackDate'])
        return df
    except Exception as e:
        print(f"Error loading data: {e}")
        return None


def create_time_series(df, country, target_col='Total_Attack_Percentage'):
    country_df = df[df['Country'] == country].sort_values('AttackDate')
    return country_df[['AttackDate', target_col]].set_index('AttackDate')


def preprocess_data(series, seq_length=10):
    scaler = MinMaxScaler()
    data = scaler.fit_transform(series.values.reshape(-1, 1))
    X, y = [], []
    for i in range(len(data) - seq_length):
        X.append(data[i:i + seq_length])
        y.append(data[i + seq_length])
    return np.array(X), np.array(y), scaler


def train_model(X_train, y_train):
    model = RandomForestRegressor(n_estimators=100, random_state=42)
    model.fit(X_train, y_train)
    return model


def predict_future(model, last_sequence, scaler, steps=180):
    future_predictions = []
    current_sequence = last_sequence.copy()

    for _ in range(steps):
        next_pred = model.predict(current_sequence.reshape(1, -1))
        future_predictions.append(next_pred[0])
        current_sequence = np.roll(current_sequence, -1)
        current_sequence[-1] = next_pred[0]

    future_predictions = np.array(future_predictions).reshape(-1, 1)
    future_predictions = scaler.inverse_transform(future_predictions)
    return future_predictions.flatten()


def plot_loss(y_true, y_pred, country):
    mse = mean_squared_error(y_true, y_pred)
    plt.figure()
    plt.plot(y_true, label='True')
    plt.plot(y_pred, label='Predicted')
    plt.title(f'Model Performance for {country} (MSE: {mse:.4f})')
    plt.xlabel('Time')
    plt.ylabel('Attack Percentage')
    plt.legend()
    plt.savefig(f'loss_{country.replace(" ", "_")}.png')
    plt.close()


def plot_forecast(future_vals, country):
    days = np.arange(1, len(future_vals)+1)
    plt.figure(figsize=(10, 5))
    plt.plot(days, future_vals, label='Forecasted Attack Percentage')
    plt.title(f'6-Month Forecast for {country}')
    plt.xlabel('Days into Future')
    plt.ylabel('Attack Percentage')
    plt.grid(True)
    plt.legend()
    plt.savefig(f'forecast_{country.replace(" ", "_")}.png')
    plt.close()


if __name__ == "__main__":
    data_path = "cleanedd_Attack_file.xlsx"

    df = load_data(data_path)
    if df is None or df.empty:
        print("Loaded data is empty or invalid.")
        exit(1)

    top_countries = df.groupby('Country')['Total_Attack_Percentage'].mean().nlargest(10).index
    seq_length = 10
    future_predictions = {}

    for country in top_countries:
        series = create_time_series(df, country)
        if series.empty:
            print(f"No data for {country}")
            continue

        X, y, scaler = preprocess_data(series, seq_length)
        if len(X) < 20:
            print(f"Insufficient data for {country}")
            continue

        X_flat = X.reshape((X.shape[0], X.shape[1]))
        X_train, X_test, y_train, y_test = train_test_split(X_flat, y, test_size=0.2, random_state=42)

        print(f"Training model for {country}")
        model = train_model(X_train, y_train)

        predictions = model.predict(X_test)
        try:
            predictions_inv = scaler.inverse_transform(predictions.reshape(-1, 1))
            y_test_inv = scaler.inverse_transform(y_test.reshape(-1, 1))
        except ValueError as e:
            print(f"Scaler inverse transform failed for {country}: {e}")
            continue

        rmse = np.sqrt(np.mean((predictions_inv - y_test_inv) ** 2))
        print(f'RMSE for {country}: {rmse}')

        plot_loss(y_test_inv, predictions_inv, country)

        last_sequence = X[-1].reshape(-1)
        future_vals = predict_future(model, last_sequence, scaler, steps=180)
        avg_future = np.mean(future_vals)
        last_value = scaler.inverse_transform([y[-1]])[0]
        percentage_change = ((avg_future - last_value) / last_value) * 100
        percentage_change = percentage_change.item()
        future_predictions[country] = percentage_change
        print(f"Future prediction for {country}: {percentage_change:.2f}% change over the next 6 months")

        plot_forecast(future_vals, country)

    os.makedirs('web', exist_ok=True)
    with open('web/future_predictions.json', 'w') as f:
        json.dump(future_predictions, f, indent=2)
    print("Future predictions saved to web/future_predictions.json")
